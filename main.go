package main

import (
	"bufio"
	"database/sql"
	"flag"
	"fmt"
	"io/fs"
	"log"
	_ "modernc.org/sqlite"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

const (
	template = `# This data file generated by 23andMe at: Thu Oct 17 17:09:07 2019
#
# This file contains raw genotype data, including data that is not used in 23andMe reports.
# This data has undergone a general quality review however only a subset of markers have been
# individually validated for accuracy. As such, this data is suitable only for research,
# educational, and informational use and not for medical or other use.
#
# Below is a text version of your data.  Fields are TAB-separated
# Each line corresponds to a single SNP.  For each SNP, we provide its identifier
# (an rsid or an internal id), its location on the reference human genome, and the
# genotype call oriented with respect to the plus strand on the human reference sequence.
# We are using reference human assembly build 37 (also known as Annotation Release 104).
# Note that it is possible that data downloaded at different times may be different due to ongoing
# improvements in our ability to call genotypes. More information about these changes can be found at:
# https://you.23andme.com/p/3246e39de434df25/tools/data/download/
#
# More information on reference human assembly builds:
# https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.13/
#
# rsid	chromosome	position	genotype
`
)

type Gene struct {
	chr    string
	pos    string
	rsid   string
	ref    string
	alt    string
	allele string
	gt     string
}

func main() {
	var vcf, out string
	var v int
	flag.StringVar(&vcf, "vcf", "", "Path to the vcf")
	flag.StringVar(&out, "output", "", "Path to the output file")
	flag.IntVar(&v, "version", 5, "Version of 23AndMe (3, 4 or 5)")
	flag.Parse()

	wd, _ := os.Getwd()
	pathToDB := filepath.Join(wd, "genome.bd")
	db, err := sql.Open("sqlite", pathToDB)
	if err != nil {
		log.Fatal(err)
	}
	concurrencyLevel := runtime.NumCPU() * 8
	db.SetMaxIdleConns(concurrencyLevel)
	defer db.Close()

	if vcf == "" {
		filepath.WalkDir(wd, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if filepath.Ext(d.Name()) == ".vcf" {
				vcf = d.Name()
			}
			return nil
		})
	}

	fileInput, err := os.Open(vcf)
	if err != nil {
		log.Fatalln(err)
	}
	defer fileInput.Close()

	var genome []*Gene
	scanner := bufio.NewScanner(fileInput)
	for scanner.Scan() {
		if strings.HasPrefix(scanner.Text(), "#") {
			continue
		}

		line := strings.SplitN(scanner.Text(), "\t", 10)
		gene := &Gene{
			chr:    line[0],
			pos:    line[1],
			rsid:   line[2],
			ref:    line[3],
			alt:    line[4],
			allele: line[9],
		}

		if len(gene.ref) > 1 || len(gene.alt) > 1 {
			continue
		}
		if !(strings.HasPrefix(gene.rsid, "rs") || strings.HasPrefix(gene.rsid, "i")) || strings.Contains(gene.rsid, ";") {
			continue
		}

		val := strings.SplitN(gene.allele, "/", 2)
		if val[0] == "0" {
			gene.gt = gene.ref
		} else {
			gene.gt = gene.alt
		}
		if len(val) > 1 {
			if val[1] == "0" {
				gene.gt += gene.ref
			} else {
				gene.gt += gene.alt
			}
		}
		genome = append(genome, gene)
	}
	if err := scanner.Err(); err != nil {
		log.Fatalln(err)
	}

	db.Exec("DROP TABLE IF EXISTS [tmpGenotek]")
	_, err = db.Exec("CREATE TABLE [tmpGenotek] (rsid TEXT PRIMARY KEY, gt TEXT NOT NULL)")
	if err != nil {
		log.Fatalln(err)
	}

	var placeholder []string
	for _, g := range genome {
		placeholder = append(placeholder, fmt.Sprintf("('%s','%s')", g.rsid, g.gt))
	}
	res := strings.Join(placeholder, ",")
	_, err = db.Exec(fmt.Sprintf("INSERT INTO [tmpGenotek] (rsid, gt) VALUES %s", res))
	if err != nil {
		log.Fatalln(err)
	}

	if out == "" {
		out = fmt.Sprintf(strings.ReplaceAll(fileInput.Name(), ".vcf", "_23AndMeV%d.txt"), v)
	}

	fileOutput, err := os.Create(out)
	if err != nil {
		log.Fatalln(err)
	}
	defer fileOutput.Close()

	fileOutput.WriteString(template)

	rows, _ := db.Query(fmt.Sprintf("SELECT [%d].rsid, [%d].chr, [%d].pos, CASE WHEN [tmpGenotek].gt IS NULL THEN '--' ELSE [tmpGenotek].gt END FROM [%d] LEFT JOIN [tmpGenotek] ON [%d].rsid = [tmpGenotek].rsid", v, v, v, v, v))
	for rows.Next() {
		var rsid, chr, pos, gt string
		rows.Scan(&rsid, &chr, &pos, &gt)
		fileOutput.WriteString(fmt.Sprintf("%s\t%s\t%s\t%s\n", rsid, chr, pos, gt))
	}

	outputPath, _ := filepath.Abs(fileOutput.Name())
	fmt.Println(fmt.Sprintf("%s\tУСПЕШНО!", outputPath))
}
